<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dictionary Update Tool</title>
    
    <!-- Google Fonts for Myanmar support -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Myanmar:wght@400;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
            margin: 20px; 
            background: #f5f5f5;
            color: #1f2937;
            line-height: 1.6;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
        }
        h1 { 
            color: #1f2937; 
            text-align: center; 
            margin-bottom: 30px; 
        }
        .step {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .step h3 {
            color: #2563eb;
            margin-top: 0;
        }
        button { 
            padding: 12px 24px; 
            margin: 10px; 
            background: #2563eb; 
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 14px;
            font-weight: 600;
        }
        button:hover { background: #1d4ed8; }
        button:disabled { background: #9ca3af; cursor: not-allowed; }
        .success { background: #10b981; }
        .success:hover { background: #059669; }
        .danger { background: #ef4444; }
        .danger:hover { background: #dc2626; }
        textarea { 
            width: 100%; 
            height: 400px; 
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; 
            font-size: 12px;
            padding: 16px; 
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #f9fafb;
            resize: vertical;
        }
        .log { 
            background: #f3f4f6; 
            padding: 16px; 
            margin: 16px 0; 
            border-radius: 8px; 
            white-space: pre-wrap; 
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            font-weight: 600;
        }
        .status.success { background: #d1fae5; color: #065f46; border: 1px solid #a7f3d0; }
        .status.error { background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; }
        .status.info { background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; }
        .code-block {
            background: #1f2937;
            color: #f9fafb;
            padding: 16px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
            margin: 12px 0;
        }
        .highlight { background-color: #fef3c7; padding: 2px 4px; border-radius: 4px; }
        
        /* Myanmar font support */
        .myanmar-text {
            font-family: 'Noto Sans Myanmar', 'Myanmar Text', sans-serif;
            font-size: 14px;
            line-height: 1.8;
        }
        
        /* Word preview styling */
        .word-preview {
            font-family: 'Noto Sans Myanmar', 'Myanmar Text', 'Inter', sans-serif;
            line-height: 1.6;
        }
        
        /* Better typography */
        h1 { 
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            color: #111827;
        }
        
        h3 {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            color: #1f2937;
        }
        
        /* Improve button fonts */
        button {
            font-family: 'Inter', sans-serif;
            font-weight: 500;
        }
        
        /* Fix emoji rendering */
        .emoji {
            font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1><span class="emoji">üìö</span> Dictionary Update Tool</h1>
        <p>This tool helps you update your local dictionary file with approved words from Firebase.</p>

        <div class="step">
            <h3>Step 1: Fetch Updates from Firebase</h3>
            <p>Click to fetch approved words from your Firebase database.</p>
            <button onclick="fetchUpdates()">Fetch Updates from Firebase</button>
            <div id="fetch-status"></div>
        </div>

        <div class="step">
            <h3>Step 2: Generate Updated Dictionary File</h3>
            <p>Review the fetched updates and generate the new dictionary file content.</p>
            <button onclick="generateDictionaryFile()" id="generate-btn" disabled>Generate Dictionary File</button>
            <div id="updates-preview"></div>
        </div>

        <div class="step">
            <h3>Step 3: Copy & Apply Updates</h3>
            <p>Copy the generated content and replace your <span class="highlight">dictionary.ts</span> file.</p>
            <textarea id="dictionary-output" placeholder="Generated dictionary file content will appear here..." readonly></textarea>
            <div style="text-align: center; margin-top: 16px;">
                <button onclick="copyToClipboard()" class="success" id="copy-btn" disabled><span class="emoji">üìã</span> Copy to Clipboard</button>
                <button onclick="downloadFile()" class="success" id="download-btn" disabled><span class="emoji">üíæ</span> Download File</button>
            </div>
        </div>

        <div class="step">
            <h3>Step 4: Manual File Update</h3>
            <div class="code-block">
# Navigate to your app directory
cd /Users/aungkoko/mm_kr/app/data

# Backup your current dictionary (optional)
cp dictionary.ts dictionary.ts.backup

# Replace the content of dictionary.ts with the generated content
# You can use any text editor (VS Code, nano, vim, etc.)
code dictionary.ts
            </div>
            <p><strong>After updating the file:</strong></p>
            <ul>
                <li>Save the file</li>
                <li>Restart your React Native app</li>
                <li>New words should appear in search results</li>
            </ul>
        </div>

        <div id="log" class="log" style="display: none;"></div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';
        import { getFirestore, collection, getDocs, query, orderBy } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js';

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyDOT1jC27f26f3BIW-yFcgHTLGdEWeiopQ",
            authDomain: "mm-kr-expo.firebaseapp.com",
            projectId: "mm-kr-expo",
            storageBucket: "mm-kr-expo.firebasestorage.app",
            messagingSenderId: "974504645463",
            appId: "1:974504645463:web:0cd68a7b52ea2bcddb6412"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Static dictionary entries (current local data)
        const staticDictionary = [
            { id: '1', korean: 'ÏïàÎÖïÌïòÏÑ∏Ïöî', myanmar: '·Äô·ÄÑ·Ä∫·Äπ·ÄÇ·Äú·Ä¨·Äï·Ä´', english: 'Hello', pos: 'interjection' },
            { id: '2', korean: 'Í∞êÏÇ¨Ìï©ÎãàÎã§', myanmar: '·ÄÄ·Äª·Ä±·Ä∏·Äá·Ä∞·Ä∏·Äê·ÄÑ·Ä∫·Äï·Ä´·Äê·Äö·Ä∫', english: 'Thank you', pos: 'interjection' },
            { id: '3', korean: 'ÎÑ§', myanmar: '·Äü·ÄØ·Äê·Ä∫·ÄÄ·Ä≤·Ä∑', english: 'Yes', pos: 'interjection' },
            { id: '4', korean: 'ÏïÑÎãàÏöî', myanmar: '·Äô·Äü·ÄØ·Äê·Ä∫·Äò·Ä∞·Ä∏', english: 'No', pos: 'interjection' },
            { id: '5', korean: 'ÏùåÏãù', myanmar: '·Ä°·ÄÖ·Ä¨·Ä∏·Ä°·Äû·Ä±·Ä¨·ÄÄ·Ä∫', english: 'Food', pos: 'noun' },
            { id: '6', korean: 'Î¨º', myanmar: '·Äõ·Ä±', english: 'Water', pos: 'noun' },
            { id: '7', korean: 'ÌïôÍµê', myanmar: '·ÄÄ·Äª·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏', english: 'School', pos: 'noun' },
            { id: '8', korean: 'ÏπúÍµ¨', myanmar: '·Äû·Ä∞·ÄÑ·Äö·Ä∫·ÄÅ·Äª·ÄÑ·Ä∫·Ä∏', english: 'Friend', pos: 'noun' },
            { id: '9', korean: 'ÏÇ¨Îûë', myanmar: '·ÄÅ·Äª·ÄÖ·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏', english: 'Love', pos: 'noun' },
            { id: '10', korean: 'Í∞ÄÏ°±', myanmar: '·Äô·Ä≠·Äû·Ä¨·Ä∏·ÄÖ·ÄØ', english: 'Family', pos: 'noun' },
        ];

        let firebaseUpdates = [];

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('fetch-status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.textContent += `[${timestamp}] ${message}\n`;
            logDiv.style.display = 'block';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        window.fetchUpdates = async function() {
            showStatus('<span class="emoji">üîÑ</span> Fetching updates from Firebase...', 'info');
            log('Starting to fetch updates from Firebase...');

            try {
                const q = query(collection(db, 'dictionary'), orderBy('addedAt', 'desc'));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    showStatus('<span class="emoji">‚ÑπÔ∏è</span> No words found in Firebase dictionary', 'info');
                    log('No words found in Firebase dictionary collection');
                    return;
                }

                firebaseUpdates = [];
                const existingKoreanWords = new Set(staticDictionary.map(entry => entry.korean));

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const update = {
                        id: doc.id,
                        korean: data.korean || '',
                        myanmar: data.myanmar || '',
                        english: data.english || '',
                        pos: data.pos || 'noun',
                        addedBy: data.addedBy || 'admin',
                        addedAt: data.addedAt?.toDate() || new Date(),
                        source: data.source || 'unknown',
                        isNew: !existingKoreanWords.has(data.korean)
                    };
                    firebaseUpdates.push(update);
                });

                const newWords = firebaseUpdates.filter(u => u.isNew).length;
                showStatus(`<span class="emoji">‚úÖ</span> Found ${firebaseUpdates.length} words (${newWords} new)`, 'success');
                log(`Successfully fetched ${firebaseUpdates.length} words from Firebase`);
                log(`${newWords} words are new (not in local dictionary)`);

                // Show preview
                showUpdatesPreview();
                document.getElementById('generate-btn').disabled = false;

            } catch (error) {
                showStatus(`<span class="emoji">‚ùå</span> Error fetching updates: ${error.message}`, 'error');
                log(`Error: ${error.message}`);
                console.error('Fetch error:', error);
            }
        };

        function showUpdatesPreview() {
            const previewDiv = document.getElementById('updates-preview');
            const newWords = firebaseUpdates.filter(u => u.isNew);
            
            // Find deleted words
            const currentFirebaseWords = firebaseUpdates.map(word => ({
                korean: word.korean,
                myanmar: word.myanmar
            }));
            
            const deletedWords = staticDictionary.filter(staticWord => {
                return !currentFirebaseWords.some(firebaseWord => 
                    firebaseWord.korean === staticWord.korean && 
                    firebaseWord.myanmar === staticWord.myanmar
                );
            });
            
            if (newWords.length === 0 && deletedWords.length === 0) {
                previewDiv.innerHTML = '<div class="status info"><span class="emoji">‚ÑπÔ∏è</span> No changes detected in dictionary</div>';
                return;
            }

            let html = '';
            
            // Show new words
            if (newWords.length > 0) {
                html += `<div class="status success"><span class="emoji">üìù</span> Found ${newWords.length} new words to add:</div>`;
                html += '<div style="max-height: 200px; overflow-y: auto; border: 1px solid #d1d5db; border-radius: 8px; padding: 12px; background: #f9fafb; margin-bottom: 16px;">';
                
                newWords.slice(0, 10).forEach(word => {
                    html += `<div style="margin-bottom: 8px; padding: 8px; background: white; border-radius: 4px;" class="word-preview">`;
                    html += `<strong>${word.korean}</strong> ‚Üí <span class="myanmar-text">${word.myanmar}</span>`;
                    if (word.english) html += ` (${word.english})`;
                    html += ` <span style="color: #6b7280; font-size: 12px;">[${word.pos}]</span>`;
                    html += `</div>`;
                });
                
                if (newWords.length > 10) {
                    html += `<div style="text-align: center; color: #6b7280; font-style: italic;">... and ${newWords.length - 10} more new words</div>`;
                }
                
                html += '</div>';
            }
            
            // Show deleted words
            if (deletedWords.length > 0) {
                html += `<div class="status error"><span class="emoji">üóëÔ∏è</span> Found ${deletedWords.length} words to remove:</div>`;
                html += '<div style="max-height: 200px; overflow-y: auto; border: 1px solid #d1d5db; border-radius: 8px; padding: 12px; background: #f9fafb;">';
                
                deletedWords.slice(0, 10).forEach(word => {
                    html += `<div style="margin-bottom: 8px; padding: 8px; background: #fee2e2; border-radius: 4px;" class="word-preview">`;
                    html += `<strong>${word.korean}</strong> ‚Üí <span class="myanmar-text">${word.myanmar}</span>`;
                    if (word.english) html += ` (${word.english})`;
                    html += ` <span style="color: #991b1b; font-size: 12px;">[${word.pos}]</span>`;
                    html += `</div>`;
                });
                
                if (deletedWords.length > 10) {
                    html += `<div style="text-align: center; color: #6b7280; font-style: italic;">... and ${deletedWords.length - 10} more deleted words</div>`;
                }
                
                html += '</div>';
            }
            previewDiv.innerHTML = html;
        }

        window.generateDictionaryFile = function() {
            if (firebaseUpdates.length === 0) {
                showStatus('<span class="emoji">‚ùå</span> No updates to generate. Fetch updates first.', 'error');
                return;
            }

            log('Generating updated dictionary file...');

            // Get all current Firebase words
            const currentFirebaseWords = firebaseUpdates.map(word => ({
                korean: word.korean,
                myanmar: word.myanmar,
                english: word.english || undefined,
                pos: word.pos
            }));

            // Filter out words that have been deleted from Firebase
            const activeStaticWords = staticDictionary.filter(staticWord => {
                // Keep word if it exists in Firebase
                return currentFirebaseWords.some(firebaseWord => 
                    firebaseWord.korean === staticWord.korean && 
                    firebaseWord.myanmar === staticWord.myanmar
                );
            });

            // Add new words from Firebase
            const newWords = firebaseUpdates.filter(u => u.isNew);
            const newEntries = [];
            newWords.forEach(word => {
                // Double-check to avoid duplicates
                const exists = activeStaticWords.some(entry =>
                    entry.korean === word.korean && entry.myanmar === word.myanmar
                );

                if (!exists) {
                    newEntries.push({
                        korean: word.korean,
                        myanmar: word.myanmar,
                        english: word.english || undefined,
                        pos: word.pos
                    });
                }
            });

            // Combine active static words with new entries
            const combinedEntries = [...activeStaticWords, ...newEntries];
            
            // Sort alphabetically by Korean first
            combinedEntries.sort((a, b) => a.korean.localeCompare(b.korean));
            
            // Re-assign sequential IDs after sorting
            const allEntries = combinedEntries.map((entry, index) => ({
                id: (index + 1).toString(),
                korean: entry.korean,
                myanmar: entry.myanmar,
                english: entry.english,
                pos: entry.pos
            }));

            // Generate TypeScript file content
            const fileContent = `import type { DictionaryEntry } from '../App';

// Dictionary entries - includes both initial data and approved user submissions
// Last updated: ${new Date().toLocaleString()}
// Total entries: ${allEntries.length} (${newWords.length} new from Firebase)
export const dictionaryEntries: DictionaryEntry[] = [
${allEntries.map(entry => {
    const english = entry.english ? `'${entry.english}'` : 'undefined';
    const pos = entry.pos ? `'${entry.pos}'` : 'undefined';
    return `  { id: '${entry.id}', korean: '${entry.korean}', myanmar: '${entry.myanmar}', english: ${english}, pos: ${pos} },`;
}).join('\n')}
];
`;

            document.getElementById('dictionary-output').value = fileContent;
            document.getElementById('copy-btn').disabled = false;
            document.getElementById('download-btn').disabled = false;

            const deletedWords = staticDictionary.length - activeStaticWords.length;
            showStatus(`<span class="emoji">‚úÖ</span> Generated dictionary file with ${allEntries.length} total entries (${newEntries.length} new, ${deletedWords} removed)`, 'success');
            log(`Generated dictionary file with ${allEntries.length} entries`);
            log(`Added ${newEntries.length} new words from Firebase`);
            log(`Removed ${deletedWords} words that were deleted from Firebase`);
            log(`All entries are now sorted alphabetically with sequential IDs (1-${allEntries.length})`);
        };

        window.copyToClipboard = function() {
            const textarea = document.getElementById('dictionary-output');
            textarea.select();
            document.execCommand('copy');
            
            const btn = document.getElementById('copy-btn');
            const originalText = btn.textContent;
            btn.innerHTML = '<span class="emoji">‚úÖ</span> Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
            
            log('Dictionary content copied to clipboard');
        };

        window.downloadFile = function() {
            const content = document.getElementById('dictionary-output').value;
            const blob = new Blob([content], { type: 'text/typescript' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dictionary.ts';
            a.click();
            
            URL.revokeObjectURL(url);
            log('Dictionary file downloaded');
        };
    </script>
</body>
</html>